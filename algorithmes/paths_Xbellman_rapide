//Xbellman : eXtended_bellman
//les algorithmes ci-dessous donnent tous les chemins solutions:
//ils fournissent les chemins équivalents (chemins optimaux de coûts égaux),
//contrairement à la première version

FONCTION bellman(DON G : Graphe (S,A); DON source : Sommet) : Graphe
	VARIABLES
		chemins : Graphe (S', A')
		distance_a_source : Map<Sommet, Entier>
		meilleurs_prédécesseurs : Map<Sommet, Liste<Sommet> >
		candidats : Liste<Sommet>
		en_attente_d_ajout : File<Sommet>
		i : Entier
		INFINITY := 30 000

	DÉBUT
		_initialiser(G, chemins, source, candidats, distance_a_source)
		
		//début de l'algorithme
		en_attente_d_ajout := _relaxation(G, chemins, candidats)
		TANTQUE taille(en_attente_d_ajout) > 0 FAIRE
				_correction_des_tables(G, chemins, en_attente_d_ajout, distance_a_source, meilleurs_prédécesseurs)
				_retirer_sommets(candidats, en_attente_d_ajout)
				_inserer_sommets_en_attente(G, chemins, en_attente_d_ajout, meilleurs_prédécesseurs)
				en_attente_d_ajout := _relaxation(G, chemins, candidats)
		FINTANTQUE

		retourner chemins
	FIN

PROCÉDURE _initialiser(DON G(S,A), DON-RES G'(S',A') : Graphe; DON source : Sommet; DON-RES candidats : Liste<Sommet>; DON-RES distance_a_source : Map<Sommet, Entier>)
	VARIABLES
		i : Entier
		s : Sommet
		INFINI := 30000
	DÉBUT
		distance_a_source[source] = 0
		ajouter_sommet(chemins, source)
		POUR i := 1 à taille(S) FAIRE
			s = ieme(S,i)
			SI
				s != source
			ALORS
				distance_a_source[s] = INFINI
				ajouter(candidats, s, taille(candidats)+1)
			FINSI
		FINPOUR
	FIN

FONCTION _relaxation(DON G, DON G' : Graphe; DON candidats : Liste<Sommet>) : File<Sommet>
	VARIABLES
		en_attente_d_ajout : File<Sommet>
		prédécesseurs : Liste<Sommet>
		s, pred : Sommet
		i, j : Entier
		relaxable : Booléen
	DÉBUT
		POUR i:=1 à taille(candidats) FAIRE
			s := ieme(candidats, i)
			prédécesseurs := prédécesseurs(G, s)

			relaxable := FAUX

			SI
				taille(prédécesseurs) > 0
			ALORS
				relaxable := VRAI
				j:=0
				TANTQUE j < taille(prédécesseurs) ET relaxable FAIRE
					pred := ieme(prédécesseurs, j)
					SI
						NON est_sommet_de(G', pred)
					ALORS
						relaxable := FAUX
					FINSI
					j := j + 1
				FINTANTQUE
			FINSI

			SI
				relaxable
			ALORS
				enfiler(en_attente_d_ajout, s)
			FINSI
		FINPOUR

		retourner en_attente_d_ajout
	FIN

PROCÉDURE _correction_des_tables(DON G, DON chemins : Graphe; DON en_attente_d_ajout : File<Sommet>; DON-RES distance_a_source : Map<Sommet, Entier>; DON-RES meilleurs_prédécesseurs : Map<Sommet, Liste<Sommet> >)
	VARIABLE
		prédecesseurs : Set<Sommets>
		s, pred : Sommet
		i, j, nvlle_distance : Entier

	DÉBUT
		POUR i:=1 à taille(en_attente_d_ajout) FAIRE
			s := ième(en_attente_d_ajout)
			prédécesseurs := prédécesseurs(G, s)

			POUR j:=1 à taille(prédécesseurs) FAIRE
				pred := ième(prédécesseur, i)
				SI
					 est_sommet_de(chemins, pred)
				ALORS
					nvlle_distance := distance_a_source[pred] + coût(G, pred, s)
					SI
						new_distance < distance_a_source[s]
					ALORS
						distance_a_source[s] := new_distance
						vider(meilleurs_prédécesseurs[s])
						insérer(meilleurs_prédécesseurs[s], pred, 1)
					SINON
						SI
							new_distance < distance_a_source[s]
						ALORS
							insérer(meilleurs_prédécesseurs[s], pred, taille(meilleurs_prédécesseurs[s])+1)
						FINSI
					FINSI
				FINSI
			FINPOUR

		FINPOUR
	FIN	


PROCÉDURE _inserer_sommets_en_attente(DON G, DON-RES chemins : Graphe; DON-RES en_attente_d_ajout : File<Sommet>; DON meilleurs_prédécesseurs : Map<Sommet, Liste<Sommet> >)
	VARIABLES
		s, pred : Sommet
		i : Entier

	DÉBUT
		TANTQUE taille(en_attente_d_ajout) > 0 FAIRE
			s := premier(en_attente_d_ajout)
			POUR i:=1 à taille(meilleur_prédécesseur[s]) FAIRE
				pred := ième(meilleurs_prédécesseurs[s], i)
				ajouter_arc(chemins, pred, s, coût(G,pred,s))
			FINPOUR
			retirer(en_attente_d_ajout)
		FINTANTQUE
	FIN

PROCÉDURE _retirer_sommets(DON-RES candidats : Liste<Sommet>; DON en_attente_d_ajout : File<Sommet>)
	VARIABLES
		s : Sommet
		i : Entier

	DÉBUT
		POUR i := 1 à taille(en_attente_d_ajout) FAIRE
			s := ième(en_attente_d_ajout)
			retirer(candidats, s)
		FINPOUR

	FIN

