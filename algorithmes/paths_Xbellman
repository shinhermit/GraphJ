//Xbellman : eXtended_bellman
//les algorithmes ci-dessous donnent tous les chemins solutions:
//ils fournissent les chemins équivalents (chemins optimaux de coûts égaux),
//contrairement à la première version

FONCTION bellman(G : Graphe (S,A); source : Sommet) : Graphe
	VARIABLES
		chemins : Graphe (S', A')
		distance_a_source : Map<Sommet, Entier>
		meilleurs_prédécesseurs : Map<Sommet, Liste<Sommet> >
		candidats : Liste<Sommet>
		en_attente_d_ajout : File<Sommet>
		i : Entier
		INFINITY := 30 000

	DÉBUT
		//initialisations
		distance_a_source[source] := 0
		ajouter_sommet(chemins, source)
		POUR i=1 à taille(S) FAIRE
			s := ieme(S,i)
			SI
				s != source
			ALORS
				distance_a_source[s] := INFINI
				ajouter(candidats, s, taille(candidats)+1)
			FINSI
		FINPOUR
		
		//début de l'algorithme
		en_attente_d_ajout := _relaxation(G, chemins, candidats)
		TANTQUE taille(en_attente_d_ajout) > 0 FAIRE
				_correction_des_tables(G, chemins, en_attente_d_ajout, distance_a_source, meilleurs_prédécesseurs)
				_retirer_sommets(candidats, en_attente_d_ajout)
				_inserer_sommets_en_attente(G, chemins, en_attente_d_ajout, meilleurs_prédécesseurs)
				en_attente_d_ajout := _relaxation(G, chemins, candidats)
		FINTANTQUE

		retourner chemins
	FIN

FONCTION _relaxation(G, G' : Graphe; candidats : Liste<Sommet>) : File<Sommet>
	VARIABLES
		en_attente_d_ajout : File<Sommet>
		prédécesseurs : Liste<Sommet>
		s, pred : Sommet
		i, j : Entier
		relaxable : Booléen
	DÉBUT
		POUR i:=1 à taille(candidats) FAIRE
			s := ieme(candidats, i)
			prédécesseurs := prédécesseurs(G, s)
			relaxable := VRAI
			j:=0
			TANTQUE j < taille(prédécesseurs) ET relaxable FAIRE
				pred := ieme(prédécesseurs, j)
				SI
					NON est_sommet_de(G', pred)
				ALORS
					relaxable := FAUX
				FINSI
				j := j + 1
			FINTANTQUE
			SI
				relaxable
			ALORS
				enfiler(en_attente_d_ajout, s)
			FINSI
		FINPOUR

		retourner en_attente_d_ajout
	FIN

PROCÉDURE _correction_des_tables(G, chemins : Graphe en_attente_d_ajout : File<Sommet>; distance_a_source : Map<Sommet, Entier>; meilleurs_prédécesseurs : Map<Sommet, Liste<Sommet> >)
	VARIABLE
		prédecesseurs : Set<Sommets>
		s, pred : Sommet
		i, j, nvlle_distance : Entier

	DÉBUT
		POUR i:=1 à taille(en_attente_d_ajout) FAIRE
			s := ième(en_attente_d_ajout)
			prédécesseurs := prédécesseurs(G, s)

			POUR j:=1 à taille(prédécesseurs) FAIRE
				pred := ième(prédécesseur, i)
				SI
					 est_sommet_de(chemins, pred)
				ALORS
					nvlle_distance := distance_a_source[pred] + coût(G, pred, s)
					SI
						new_distance < distance_a_source[s]
					ALORS
						distance_a_source[s] := new_distance
						vider(meilleurs_prédécesseurs[s])
						insérer(meilleurs_prédécesseurs[s], pred, 1)
					SINON
						SI
							new_distance < distance_a_source[s]
						ALORS
							insérer(meilleurs_prédécesseurs[s], pred, taille(meilleurs_prédécesseurs[s])+1)
						FINSI
					FINSI
				FINSI
			FINPOUR

		FINPOUR
	FIN	


PROCÉDURE _inserer_sommets_en_attente(G, chemins : Graphe; en_attente_d_ajout : File<Sommet>; meilleurs_prédécesseurs : Map<Sommet, Liste<Sommet> >)
	VARIABLES
		s, pred : Sommet
		i : Entier

	DÉBUT
		TANTQUE taille(en_attente_d_ajout) > 0 FAIRE
			s := premier(en_attente_d_ajout)
			POUR i:=1 à taille(meilleur_prédécesseur[s]) FAIRE
				pred := ième(meilleurs_prédécesseurs[s], i)
				ajouter_arc(chemins, pred, s, coût(G,pred,s))
			FINPOUR
			retirer(en_attente_d_ajout)
		FINTANTQUE
	FIN

PROCÉDURE _retirer_sommets(candidats : Liste<Sommet>; en_attente_d_ajout : File<Sommet>)
	VARIABLES
		s : Sommet
		i : Entier

	DÉBUT
		POUR i := 1 à taille(en_attente_d_ajout) FAIRE
			s := ième(en_attente_d_ajout)
			retirer(candidats, s)
		FINPOUR

	FIN

