SDD, TAD (lien avec le cours l'année dernière)
---------

	*toute la puissance de l'abstraction (interopérabilité, utilisation avant implémentation...)
	*Utilité des SDD et de l'encapslation (mise à profit des SDD de la STL: map, set)

Kruskal & Prim
--------------

	*Donner les algorithmes de Kruskal et Prim
	*nos algorithmes ne donnent qu'une des solutions possibles, lorsqu'il en existe plusieurs
	*Amélioration possibles (non implémentées):
		*D'une manière générale: remplacer les structures lourdes (arbres, map, set) en retours de fonctions par un passage de paramètre en mode résultat (par référence en pratique)
		*Kruskal: lors du tri, garder les autres ordres possibles pour les valeurs égales
		*Prim: lors du choix du sommet le plus proche, mettre en liste d'attente les autres choix possibles.
	*Remarque: (voir fichier test_acm_directed.cpp
		*L'agorithme de Kruskal marche avec un graphe orienté
		*L'algorithme de Prim ne fonctionne pas avec un graphe orienté
			*compréhensible, connaissant notre représentation: le plus proche adjacent n'est pris que dans le liste des successeurs du noeud, où ne figure pas les arêtes entrantes (qui peuvent avoir un coût plus faible)
				*Cela est cohérent avec le fait que la liste d'adjacence, tout comme l'algortihme de Kruskal, est orienté arête (ou arc)
		*CORRECTION de la section ci-dessus: pour que l'algorithme de Prim fonctionne avec les graphes orientés, il faut bien prendre la précaution de "fusionner" les sommets en tenant compte des deux sens (le traiter comme un non orienté).
